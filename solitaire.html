<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Klondike Solitaire</title>
  <style>
    :root {
      --card-w: 100px;
      --card-h: 140px;
    }
    * {
      box-sizing: border-box;
    }
    body {
      margin: 0;
      font-family: sans-serif;
      background: green;
      user-select: none;
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100vh;
    }
    .game-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 15px;
    }
    .buttons {
      display: flex;
      gap: 10px;
    }
    button {
      font-size: 16px;
      padding: 6px 14px;
      border-radius: 6px;
      border: none;
      cursor: pointer;
    }
    button:disabled {
      background: #888;
      color: #ccc;
      cursor: not-allowed;
    }
    .board {
      display: flex;
      flex-direction: column;
      gap: 20px;
      padding: 20px;
      max-width: 900px;
      width: 100%;
    }
    .row {
      display: flex;
      gap: 10px;
      justify-content: center;
    }
    .pile, .stack {
      width: var(--card-w);
      min-height: var(--card-h);
      background: rgba(255,255,255,0.1);
      border: 2px dashed white;
      border-radius: 8px;
      position: relative;
    }
    .stack {
      min-height: 420px;
    }
    .card {
      width: var(--card-w);
      height: var(--card-h);
      border-radius: 8px;
      border: 1px solid #888;
      position: absolute;
      background: white;
      cursor: grab;
    }
    .card.faceDown {
      background: navy;
    }
    .card.faceUp {
      display: flex;
      align-items: flex-start;
      justify-content: flex-start;
      padding: 4px;
      font-size: 20px;
      font-weight: bold;
    }
    .red {
      color: red;
    }
  </style>
</head>
<body>
  <div class="game-container">
    <div class="buttons">
      <button id="resetBtn">üîÅ Reset</button>
      <button id="autoBtn" disabled>ü™Ñ Auto Complete</button>
    </div>
    <div class="board">
      <div class="row">
        <div id="stock" class="pile"></div>
        <div id="waste" class="pile"></div>
        <div style="width: 120px;"></div>
        <div id="foundation0" class="pile"></div>
        <div id="foundation1" class="pile"></div>
        <div id="foundation2" class="pile"></div>
        <div id="foundation3" class="pile"></div>
      </div>
      <div class="row" id="tableau"></div>
    </div>
  </div>

  <script>
    const suits  = ['‚ô†','‚ô•','‚ô£','‚ô¶'];
    const values = ['A','2','3','4','5','6','7','8','9','10','J','Q','K'];
    let stock=[], waste=[], foundations=[[],[],[],[]], tableau=[[],[],[],[],[],[],[]];

    const resetBtn = document.getElementById("resetBtn");
    const autoBtn = document.getElementById("autoBtn");

    resetBtn.onclick = () => newGame();
    autoBtn.onclick = () => autoComplete();

    const rndId = () => Math.random().toString(36).slice(2,9);
    const allCards = () => [...stock,...waste,...foundations.flat(),...tableau.flat()];
    const findCard = id => allCards().find(c=>c.id===id);
    const findPile = c => waste.includes(c)?waste : foundations.find(f=>f.includes(c))||tableau.find(t=>t.includes(c));

    function newGame(){
      const deck=[];
      for(const s of suits) for(let i=0;i<values.length;i++)
        deck.push({id:rndId(),suit:s,value:values[i],idx:i,
                   color:(s==='‚ô•'||s==='‚ô¶')?'red':'black',faceUp:false});
      deck.sort(()=>Math.random()-0.5);
      tableau.forEach((col,i)=>{
        tableau[i]=[];
        for(let j=0;j<=i;j++){
          const c=deck.pop();
          c.faceUp=j===i;
          tableau[i].push(c);
        }
      });
      stock=deck; waste.length=0; foundations.forEach(f=>f.length=0);
      draw();
    }

    function draw(){
      drawStock(); drawWaste(); drawFoundations(); drawTableau(); checkWin();
      updateButtons();
    }

    function updateButtons() {
      const allFaceUp = tableau.every(col => col.every(card => card.faceUp));
      autoBtn.disabled = !allFaceUp;
    }

    function cardEl(card){
      const el=document.createElement('div');
      el.className=`card ${card.faceUp?'faceUp':'faceDown'} ${card.color}`;
      el.id=card.id;
      if(card.faceUp) el.textContent=card.value+card.suit;
      el.draggable=card.faceUp;
      el.ondragstart=e=>e.dataTransfer.setData('text',card.id);
      return el;
    }

    function drawStock(){
      const el=document.getElementById('stock'); el.innerHTML='';
      const stub=document.createElement('div'); stub.className='card faceDown';
      if(stock.length){
        stub.onclick=()=>{ const c=stock.pop(); c.faceUp=true; waste.push(c); draw();};
      }else{
        stub.style.background='transparent';
        stub.onclick=()=>{ stock=waste.reverse().map(c=>(c.faceUp=false,c)); waste.length=0; draw();};
      }
      el.appendChild(stub);
    }

    function drawWaste(){
      const el=document.getElementById('waste'); el.innerHTML='';
      if(waste.length) el.appendChild(cardEl(waste[waste.length-1]));
    }

    function drawFoundations(){
      foundations.forEach((pile,i)=>{
        const el=document.getElementById('foundation'+i); el.innerHTML='';
        if(pile.length) el.appendChild(cardEl(pile[pile.length-1]));
        el.ondragover=e=>e.preventDefault();
        el.ondrop = e=>{
          const c=findCard(e.dataTransfer.getData('text')), from=findPile(c), top=pile[pile.length-1];
          if((!top&&c.value==='A')||(top&&top.suit===c.suit&&c.idx===top.idx+1)) moveCards(from,pile,c);
        };
      });
    }

    function drawTableau(){
      const board=document.getElementById('tableau'); board.innerHTML='';
      tableau.forEach((pile,pi)=>{
        const stack=document.createElement('div'); stack.className='stack';
        let y=0;
        pile.forEach(card=>{
          const el=cardEl(card); el.style.top=y+'px';
          y+=card.faceUp?30:8;
          stack.appendChild(el);
        });
        stack.ondragover=e=>e.preventDefault();
        stack.ondrop=e=>{
          const c=findCard(e.dataTransfer.getData('text')), from=findPile(c), tgt=tableau[pi], top=tgt[tgt.length-1];
          if((!tgt.length&&c.value==='K')||(top&&top.color!==c.color&&c.idx===top.idx-1)){
            const start=from.indexOf(c), moving=from.splice(start);
            tgt.push(...moving);
            if(from.length && !from[from.length-1].faceUp) from[from.length-1].faceUp=true;
            draw();
          }
        };
        board.appendChild(stack);
      });
    }

    function moveCards(from,to,card){
      const idx = from.indexOf(card);
      const moving = from.splice(idx);
      to.push(...moving);
      const last = from[from.length - 1];
      if (last && !last.faceUp) last.faceUp = true;
      draw();
    }

    function autoComplete(){
      let moved;
      do {
        moved = false;
        const piles = [...tableau, waste];
        for (const pile of piles) {
          const card = pile[pile.length - 1];
          if (!card || !card.faceUp) continue;
          for (const foundation of foundations) {
            const top = foundation[foundation.length - 1];
            if ((!top && card.value === 'A') || (top && top.suit === card.suit && card.idx === top.idx + 1)) {
              pile.pop();
              foundation.push(card);
              const last = pile[pile.length - 1];
              if (last && !last.faceUp) last.faceUp = true;
              moved = true;
              break;
            }
          }
        }
      } while (moved);
      draw();
    }

    function checkWin(){
      if(foundations.every(f=>f.length===13)) setTimeout(()=>alert("üéâ Du vann!"),300);
    }

    newGame();
  </script>
</body>
</html>
