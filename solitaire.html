<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
  <title>Klondike Solitaire</title>
  <style>
    :root {
      --card-w: 80px;
      --card-h: 112px;
    }
    html, body {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      overflow: hidden;
      touch-action: manipulation;
    }
    body {
      font-family: sans-serif;
      background: green;
      user-select: none;
      display: flex;
      justify-content: center;
      align-items: center;
    }
    .game-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 12px;
      padding: 10px;
      transform-origin: top center;
      scale: 1;
    }
    .buttons {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      justify-content: center;
    }
    button {
      font-size: 16px;
      padding: 10px 16px;
      border-radius: 6px;
      border: none;
      cursor: pointer;
    }
    button:disabled {
      background: #888;
      color: #ccc;
      cursor: not-allowed;
    }
    .board {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    .row {
      display: flex;
      gap: 6px;
      justify-content: center;
    }
    .pile, .stack {
      width: var(--card-w);
      min-height: var(--card-h);
      background: rgba(255,255,255,0.1);
      border: 2px dashed white;
      border-radius: 8px;
      position: relative;
      touch-action: none;
    }
    .stack {
      min-height: 400px;
    }
    .card {
      width: var(--card-w);
      height: var(--card-h);
      border-radius: 8px;
      border: 1px solid #888;
      position: absolute;
      background: white;
      touch-action: none;
      transition: transform 0.2s ease;
    }
    .card.dragging {
      transform: scale(1.05);
      z-index: 1000;
    }
    .card.faceDown {
      background: navy;
    }
    .card.faceUp {
      display: flex;
      align-items: flex-start;
      justify-content: flex-start;
      padding: 4px;
      font-size: 16px;
      font-weight: bold;
    }
    .red {
      color: red;
    }
    @media (max-width: 600px) {
      :root {
        --card-w: 60px;
        --card-h: 84px;
      }
    }
  </style>
</head>
<body>
  <div class="game-container">
    <div class="buttons">
      <button id="resetBtn">üîÅ Reset</button>
      <button id="autoBtn" disabled>ü™Ñ Auto Complete</button>
    </div>
    <div class="board">
      <div class="row">
        <div id="stock" class="pile"></div>
        <div id="waste" class="pile"></div>
        <div style="width: 10px;"></div>
        <div id="foundation0" class="pile"></div>
        <div id="foundation1" class="pile"></div>
        <div id="foundation2" class="pile"></div>
        <div id="foundation3" class="pile"></div>
      </div>
      <div class="row" id="tableau"></div>
    </div>
  </div>

  <script>
    const suits = ['‚ô†', '‚ô•', '‚ô£', '‚ô¶'];
    const values = ['A','2','3','4','5','6','7','8','9','10','J','Q','K'];
    let stock=[], waste=[], foundations=[[],[],[],[]], tableau=[[],[],[],[],[],[],[]];

    const resetBtn = document.getElementById("resetBtn");
    const autoBtn = document.getElementById("autoBtn");

    resetBtn.onclick = () => newGame();
    autoBtn.onclick = () => autoComplete();

    const rndId = () => Math.random().toString(36).slice(2,9);
    const allCards = () => [...stock,...waste,...foundations.flat(),...tableau.flat()];
    const findCard = id => allCards().find(c=>c.id===id);
    const findPile = c => waste.includes(c)?waste : foundations.find(f=>f.includes(c))||tableau.find(t=>t.includes(c));

    function newGame(){
      const deck=[];
      for(const s of suits) for(let i=0;i<values.length;i++)
        deck.push({id:rndId(),suit:s,value:values[i],idx:i,color:(s==='‚ô•'||s==='‚ô¶')?'red':'black',faceUp:false});
      deck.sort(()=>Math.random()-0.5);
      tableau.forEach((col,i)=>{
        tableau[i]=[];
        for(let j=0;j<=i;j++){
          const c=deck.pop();
          c.faceUp=j===i;
          tableau[i].push(c);
        }
      });
      stock=deck; waste.length=0; foundations.forEach(f=>f.length=0);
      draw();
    }

    function draw(){
      drawStock(); drawWaste(); drawFoundations(); drawTableau(); checkWin();
      updateButtons();
    }

    function updateButtons() {
      const allFaceUp = tableau.every(col => col.every(card => card.faceUp));
      autoBtn.disabled = !allFaceUp;
    }

    function cardEl(card){
      const el=document.createElement('div');
      el.className=`card ${card.faceUp?'faceUp':'faceDown'} ${card.color}`;
      el.id=card.id;
      if(card.faceUp) el.textContent=card.value+card.suit;
      el.addEventListener('pointerdown', pointerStart);
      return el;
    }

    function pointerStart(e) {
      const el = e.currentTarget;
      const id = el.id;
      const card = findCard(id);
      if (!card || !card.faceUp) return;
      el.setPointerCapture(e.pointerId);
      el.classList.add('dragging');

      const from = findPile(card);
      const originalX = e.clientX;
      const originalY = e.clientY;
      const rect = el.getBoundingClientRect();
      const offsetX = originalX - rect.left;
      const offsetY = originalY - rect.top;

      function move(ev) {
        el.style.left = (ev.clientX - offsetX) + 'px';
        el.style.top = (ev.clientY - offsetY) + 'px';
      }

      function end(ev) {
        el.classList.remove('dragging');
        el.style.left = '';
        el.style.top = '';
        el.releasePointerCapture(ev.pointerId);
        draw(); // just redraw to snap into place
        el.removeEventListener('pointermove', move);
        el.removeEventListener('pointerup', end);
        el.removeEventListener('pointercancel', end);
      }

      el.addEventListener('pointermove', move);
      el.addEventListener('pointerup', end);
      el.addEventListener('pointercancel', end);
    }

    function drawStock(){
      const el=document.getElementById('stock'); el.innerHTML='';
      const stub=document.createElement('div'); stub.className='card faceDown';
      if(stock.length){
        stub.onclick=()=>{ const c=stock.pop(); c.faceUp=true; waste.push(c); draw();};
      }else{
        stub.style.background='transparent';
        stub.onclick=()=>{ stock=waste.reverse().map(c=>(c.faceUp=false,c)); waste.length=0; draw();};
      }
      el.appendChild(stub);
    }

    function drawWaste(){
      const el=document.getElementById('waste'); el.innerHTML='';
      if(waste.length) el.appendChild(cardEl(waste[waste.length-1]));
    }

    function drawFoundations(){
      foundations.forEach((pile,i)=>{
        const el=document.getElementById('foundation'+i); el.innerHTML='';
        if(pile.length) el.appendChild(cardEl(pile[pile.length-1]));
      });
    }

    function drawTableau(){
      const board=document.getElementById('tableau'); board.innerHTML='';
      tableau.forEach((pile,pi)=>{
        const stack=document.createElement('div'); stack.className='stack';
        let y=0;
        pile.forEach(card=>{
          const el=cardEl(card); el.style.top=y+'px';
          y+=card.faceUp?30:8;
          stack.appendChild(el);
        });
        board.appendChild(stack);
      });
    }

    function moveCards(from,to,card){
      const idx = from.indexOf(card);
      const moving = from.splice(idx);
      to.push(...moving);
      const last = from[from.length - 1];
      if (last && !last.faceUp) last.faceUp = true;
      draw();
    }

    function autoComplete(){
      let moved;
      do {
        moved = false;
        const piles = [...tableau, waste];
        for (const pile of piles) {
          const card = pile[pile.length - 1];
          if (!card || !card.faceUp) continue;
          for (const foundation of foundations) {
            const top = foundation[foundation.length - 1];
            if ((!top && card.value === 'A') || (top && top.suit === card.suit && card.idx === top.idx + 1)) {
              pile.pop();
              foundation.push(card);
              const last = pile[pile.length - 1];
              if (last && !last.faceUp) last.faceUp = true;
              moved = true;
              break;
            }
          }
        }
      } while (moved);
      draw();
    }

    function checkWin(){
      if(foundations.every(f=>f.length===13)) setTimeout(()=>alert("üéâ Du vann!"),300);
    }

    newGame();
  </script>
</body>
</html>
